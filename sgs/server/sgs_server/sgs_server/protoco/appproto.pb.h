// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: appproto.proto

#ifndef PROTOBUF_appproto_2eproto_INCLUDED
#define PROTOBUF_appproto_2eproto_INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_appproto_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[28];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPlayerImpl();
void InitDefaultsPlayer();
void InitDefaultsReqLoginImpl();
void InitDefaultsReqLogin();
void InitDefaultsReqLoginUcImpl();
void InitDefaultsReqLoginUc();
void InitDefaultsReqLogoutImpl();
void InitDefaultsReqLogout();
void InitDefaultsReqLogoutUcImpl();
void InitDefaultsReqLogoutUc();
void InitDefaultsReqRegistImpl();
void InitDefaultsReqRegist();
void InitDefaultsReqRegistUcImpl();
void InitDefaultsReqRegistUc();
void InitDefaultsReqUpdatePwdImpl();
void InitDefaultsReqUpdatePwd();
void InitDefaultsReqUpdatePwdUcImpl();
void InitDefaultsReqUpdatePwdUc();
void InitDefaultsReqGetFriendsImpl();
void InitDefaultsReqGetFriends();
void InitDefaultsReqGetFriendsUcImpl();
void InitDefaultsReqGetFriendsUc();
void InitDefaultsReqAddFriendsImpl();
void InitDefaultsReqAddFriends();
void InitDefaultsReqAddFriendsUcImpl();
void InitDefaultsReqAddFriendsUc();
void InitDefaultsReqDeleteFriendImpl();
void InitDefaultsReqDeleteFriend();
void InitDefaultsReqDeleteFriendUcImpl();
void InitDefaultsReqDeleteFriendUc();
void InitDefaultsRoomImpl();
void InitDefaultsRoom();
void InitDefaultsReqCreateRoomImpl();
void InitDefaultsReqCreateRoom();
void InitDefaultsReqCreateRoomUcImpl();
void InitDefaultsReqCreateRoomUc();
void InitDefaultsReqSearchRoomImpl();
void InitDefaultsReqSearchRoom();
void InitDefaultsReqSearchRoomUcImpl();
void InitDefaultsReqSearchRoomUc();
void InitDefaultsReqEnterRoomImpl();
void InitDefaultsReqEnterRoom();
void InitDefaultsReqEnterRoomFastImpl();
void InitDefaultsReqEnterRoomFast();
void InitDefaultsReqEnterRoomBcImpl();
void InitDefaultsReqEnterRoomBc();
void InitDefaultsReqQuitRoomImpl();
void InitDefaultsReqQuitRoom();
void InitDefaultsReqQuitRoomBcImpl();
void InitDefaultsReqQuitRoomBc();
void InitDefaultsReqReadyImpl();
void InitDefaultsReqReady();
void InitDefaultsReqReadyBcImpl();
void InitDefaultsReqReadyBc();
void InitDefaultsReqEmotionBCImpl();
void InitDefaultsReqEmotionBC();
inline void InitDefaults() {
  InitDefaultsPlayer();
  InitDefaultsReqLogin();
  InitDefaultsReqLoginUc();
  InitDefaultsReqLogout();
  InitDefaultsReqLogoutUc();
  InitDefaultsReqRegist();
  InitDefaultsReqRegistUc();
  InitDefaultsReqUpdatePwd();
  InitDefaultsReqUpdatePwdUc();
  InitDefaultsReqGetFriends();
  InitDefaultsReqGetFriendsUc();
  InitDefaultsReqAddFriends();
  InitDefaultsReqAddFriendsUc();
  InitDefaultsReqDeleteFriend();
  InitDefaultsReqDeleteFriendUc();
  InitDefaultsRoom();
  InitDefaultsReqCreateRoom();
  InitDefaultsReqCreateRoomUc();
  InitDefaultsReqSearchRoom();
  InitDefaultsReqSearchRoomUc();
  InitDefaultsReqEnterRoom();
  InitDefaultsReqEnterRoomFast();
  InitDefaultsReqEnterRoomBc();
  InitDefaultsReqQuitRoom();
  InitDefaultsReqQuitRoomBc();
  InitDefaultsReqReady();
  InitDefaultsReqReadyBc();
  InitDefaultsReqEmotionBC();
}
}  // namespace protobuf_appproto_2eproto
namespace proto {
namespace game {
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class ReqAddFriends;
class ReqAddFriendsDefaultTypeInternal;
extern ReqAddFriendsDefaultTypeInternal _ReqAddFriends_default_instance_;
class ReqAddFriendsUc;
class ReqAddFriendsUcDefaultTypeInternal;
extern ReqAddFriendsUcDefaultTypeInternal _ReqAddFriendsUc_default_instance_;
class ReqCreateRoom;
class ReqCreateRoomDefaultTypeInternal;
extern ReqCreateRoomDefaultTypeInternal _ReqCreateRoom_default_instance_;
class ReqCreateRoomUc;
class ReqCreateRoomUcDefaultTypeInternal;
extern ReqCreateRoomUcDefaultTypeInternal _ReqCreateRoomUc_default_instance_;
class ReqDeleteFriend;
class ReqDeleteFriendDefaultTypeInternal;
extern ReqDeleteFriendDefaultTypeInternal _ReqDeleteFriend_default_instance_;
class ReqDeleteFriendUc;
class ReqDeleteFriendUcDefaultTypeInternal;
extern ReqDeleteFriendUcDefaultTypeInternal _ReqDeleteFriendUc_default_instance_;
class ReqEmotionBC;
class ReqEmotionBCDefaultTypeInternal;
extern ReqEmotionBCDefaultTypeInternal _ReqEmotionBC_default_instance_;
class ReqEnterRoom;
class ReqEnterRoomDefaultTypeInternal;
extern ReqEnterRoomDefaultTypeInternal _ReqEnterRoom_default_instance_;
class ReqEnterRoomBc;
class ReqEnterRoomBcDefaultTypeInternal;
extern ReqEnterRoomBcDefaultTypeInternal _ReqEnterRoomBc_default_instance_;
class ReqEnterRoomFast;
class ReqEnterRoomFastDefaultTypeInternal;
extern ReqEnterRoomFastDefaultTypeInternal _ReqEnterRoomFast_default_instance_;
class ReqGetFriends;
class ReqGetFriendsDefaultTypeInternal;
extern ReqGetFriendsDefaultTypeInternal _ReqGetFriends_default_instance_;
class ReqGetFriendsUc;
class ReqGetFriendsUcDefaultTypeInternal;
extern ReqGetFriendsUcDefaultTypeInternal _ReqGetFriendsUc_default_instance_;
class ReqLogin;
class ReqLoginDefaultTypeInternal;
extern ReqLoginDefaultTypeInternal _ReqLogin_default_instance_;
class ReqLoginUc;
class ReqLoginUcDefaultTypeInternal;
extern ReqLoginUcDefaultTypeInternal _ReqLoginUc_default_instance_;
class ReqLogout;
class ReqLogoutDefaultTypeInternal;
extern ReqLogoutDefaultTypeInternal _ReqLogout_default_instance_;
class ReqLogoutUc;
class ReqLogoutUcDefaultTypeInternal;
extern ReqLogoutUcDefaultTypeInternal _ReqLogoutUc_default_instance_;
class ReqQuitRoom;
class ReqQuitRoomDefaultTypeInternal;
extern ReqQuitRoomDefaultTypeInternal _ReqQuitRoom_default_instance_;
class ReqQuitRoomBc;
class ReqQuitRoomBcDefaultTypeInternal;
extern ReqQuitRoomBcDefaultTypeInternal _ReqQuitRoomBc_default_instance_;
class ReqReady;
class ReqReadyDefaultTypeInternal;
extern ReqReadyDefaultTypeInternal _ReqReady_default_instance_;
class ReqReadyBc;
class ReqReadyBcDefaultTypeInternal;
extern ReqReadyBcDefaultTypeInternal _ReqReadyBc_default_instance_;
class ReqRegist;
class ReqRegistDefaultTypeInternal;
extern ReqRegistDefaultTypeInternal _ReqRegist_default_instance_;
class ReqRegistUc;
class ReqRegistUcDefaultTypeInternal;
extern ReqRegistUcDefaultTypeInternal _ReqRegistUc_default_instance_;
class ReqSearchRoom;
class ReqSearchRoomDefaultTypeInternal;
extern ReqSearchRoomDefaultTypeInternal _ReqSearchRoom_default_instance_;
class ReqSearchRoomUc;
class ReqSearchRoomUcDefaultTypeInternal;
extern ReqSearchRoomUcDefaultTypeInternal _ReqSearchRoomUc_default_instance_;
class ReqUpdatePwd;
class ReqUpdatePwdDefaultTypeInternal;
extern ReqUpdatePwdDefaultTypeInternal _ReqUpdatePwd_default_instance_;
class ReqUpdatePwdUc;
class ReqUpdatePwdUcDefaultTypeInternal;
extern ReqUpdatePwdUcDefaultTypeInternal _ReqUpdatePwdUc_default_instance_;
class Room;
class RoomDefaultTypeInternal;
extern RoomDefaultTypeInternal _Room_default_instance_;
}  // namespace game
}  // namespace proto
namespace google {
namespace protobuf {
template<> ::proto::game::Player* Arena::Create< ::proto::game::Player>(Arena*);
template<> ::proto::game::ReqAddFriends* Arena::Create< ::proto::game::ReqAddFriends>(Arena*);
template<> ::proto::game::ReqAddFriendsUc* Arena::Create< ::proto::game::ReqAddFriendsUc>(Arena*);
template<> ::proto::game::ReqCreateRoom* Arena::Create< ::proto::game::ReqCreateRoom>(Arena*);
template<> ::proto::game::ReqCreateRoomUc* Arena::Create< ::proto::game::ReqCreateRoomUc>(Arena*);
template<> ::proto::game::ReqDeleteFriend* Arena::Create< ::proto::game::ReqDeleteFriend>(Arena*);
template<> ::proto::game::ReqDeleteFriendUc* Arena::Create< ::proto::game::ReqDeleteFriendUc>(Arena*);
template<> ::proto::game::ReqEmotionBC* Arena::Create< ::proto::game::ReqEmotionBC>(Arena*);
template<> ::proto::game::ReqEnterRoom* Arena::Create< ::proto::game::ReqEnterRoom>(Arena*);
template<> ::proto::game::ReqEnterRoomBc* Arena::Create< ::proto::game::ReqEnterRoomBc>(Arena*);
template<> ::proto::game::ReqEnterRoomFast* Arena::Create< ::proto::game::ReqEnterRoomFast>(Arena*);
template<> ::proto::game::ReqGetFriends* Arena::Create< ::proto::game::ReqGetFriends>(Arena*);
template<> ::proto::game::ReqGetFriendsUc* Arena::Create< ::proto::game::ReqGetFriendsUc>(Arena*);
template<> ::proto::game::ReqLogin* Arena::Create< ::proto::game::ReqLogin>(Arena*);
template<> ::proto::game::ReqLoginUc* Arena::Create< ::proto::game::ReqLoginUc>(Arena*);
template<> ::proto::game::ReqLogout* Arena::Create< ::proto::game::ReqLogout>(Arena*);
template<> ::proto::game::ReqLogoutUc* Arena::Create< ::proto::game::ReqLogoutUc>(Arena*);
template<> ::proto::game::ReqQuitRoom* Arena::Create< ::proto::game::ReqQuitRoom>(Arena*);
template<> ::proto::game::ReqQuitRoomBc* Arena::Create< ::proto::game::ReqQuitRoomBc>(Arena*);
template<> ::proto::game::ReqReady* Arena::Create< ::proto::game::ReqReady>(Arena*);
template<> ::proto::game::ReqReadyBc* Arena::Create< ::proto::game::ReqReadyBc>(Arena*);
template<> ::proto::game::ReqRegist* Arena::Create< ::proto::game::ReqRegist>(Arena*);
template<> ::proto::game::ReqRegistUc* Arena::Create< ::proto::game::ReqRegistUc>(Arena*);
template<> ::proto::game::ReqSearchRoom* Arena::Create< ::proto::game::ReqSearchRoom>(Arena*);
template<> ::proto::game::ReqSearchRoomUc* Arena::Create< ::proto::game::ReqSearchRoomUc>(Arena*);
template<> ::proto::game::ReqUpdatePwd* Arena::Create< ::proto::game::ReqUpdatePwd>(Arena*);
template<> ::proto::game::ReqUpdatePwdUc* Arena::Create< ::proto::game::ReqUpdatePwdUc>(Arena*);
template<> ::proto::game::Room* Arena::Create< ::proto::game::Room>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace proto {
namespace game {

// ===================================================================

class Player : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.Player) */ {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(Player&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Player* other);
  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Player* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Player>(NULL);
  }

  Player* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Player>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Player* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account = 2;
  void clear_account();
  static const int kAccountFieldNumber = 2;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // string passwd = 3;
  void clear_passwd();
  static const int kPasswdFieldNumber = 3;
  const ::std::string& passwd() const;
  void set_passwd(const ::std::string& value);
  #if LANG_CXX11
  void set_passwd(::std::string&& value);
  #endif
  void set_passwd(const char* value);
  void set_passwd(const char* value, size_t size);
  ::std::string* mutable_passwd();
  ::std::string* release_passwd();
  void set_allocated_passwd(::std::string* passwd);

  // string name = 4;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string avatar = 5;
  void clear_avatar();
  static const int kAvatarFieldNumber = 5;
  const ::std::string& avatar() const;
  void set_avatar(const ::std::string& value);
  #if LANG_CXX11
  void set_avatar(::std::string&& value);
  #endif
  void set_avatar(const char* value);
  void set_avatar(const char* value, size_t size);
  ::std::string* mutable_avatar();
  ::std::string* release_avatar();
  void set_allocated_avatar(::std::string* avatar);

  // string registdate = 12;
  void clear_registdate();
  static const int kRegistdateFieldNumber = 12;
  const ::std::string& registdate() const;
  void set_registdate(const ::std::string& value);
  #if LANG_CXX11
  void set_registdate(::std::string&& value);
  #endif
  void set_registdate(const char* value);
  void set_registdate(const char* value, size_t size);
  ::std::string* mutable_registdate();
  ::std::string* release_registdate();
  void set_allocated_registdate(::std::string* registdate);

  // string remark = 13;
  void clear_remark();
  static const int kRemarkFieldNumber = 13;
  const ::std::string& remark() const;
  void set_remark(const ::std::string& value);
  #if LANG_CXX11
  void set_remark(::std::string&& value);
  #endif
  void set_remark(const char* value);
  void set_remark(const char* value, size_t size);
  ::std::string* mutable_remark();
  ::std::string* release_remark();
  void set_allocated_remark(::std::string* remark);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 sex = 6;
  void clear_sex();
  static const int kSexFieldNumber = 6;
  ::google::protobuf::int32 sex() const;
  void set_sex(::google::protobuf::int32 value);

  // int32 exp = 7;
  void clear_exp();
  static const int kExpFieldNumber = 7;
  ::google::protobuf::int32 exp() const;
  void set_exp(::google::protobuf::int32 value);

  // int32 level = 8;
  void clear_level();
  static const int kLevelFieldNumber = 8;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // int32 status = 9;
  void clear_status();
  static const int kStatusFieldNumber = 9;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // int32 gamestatus = 10;
  void clear_gamestatus();
  static const int kGamestatusFieldNumber = 10;
  ::google::protobuf::int32 gamestatus() const;
  void set_gamestatus(::google::protobuf::int32 value);

  // int32 seatid = 11;
  void clear_seatid();
  static const int kSeatidFieldNumber = 11;
  ::google::protobuf::int32 seatid() const;
  void set_seatid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.Player)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::internal::ArenaStringPtr passwd_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr avatar_;
  ::google::protobuf::internal::ArenaStringPtr registdate_;
  ::google::protobuf::internal::ArenaStringPtr remark_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 gamestatus_;
  ::google::protobuf::int32 seatid_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsPlayerImpl();
};
// -------------------------------------------------------------------

class ReqLogin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqLogin) */ {
 public:
  ReqLogin();
  virtual ~ReqLogin();

  ReqLogin(const ReqLogin& from);

  inline ReqLogin& operator=(const ReqLogin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqLogin(ReqLogin&& from) noexcept
    : ReqLogin() {
    *this = ::std::move(from);
  }

  inline ReqLogin& operator=(ReqLogin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLogin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqLogin* internal_default_instance() {
    return reinterpret_cast<const ReqLogin*>(
               &_ReqLogin_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ReqLogin* other);
  friend void swap(ReqLogin& a, ReqLogin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqLogin* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqLogin>(NULL);
  }

  ReqLogin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqLogin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqLogin& from);
  void MergeFrom(const ReqLogin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqLogin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account = 1;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // string pwd = 2;
  void clear_pwd();
  static const int kPwdFieldNumber = 2;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const char* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);

  // @@protoc_insertion_point(class_scope:proto.game.ReqLogin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqLoginImpl();
};
// -------------------------------------------------------------------

class ReqLoginUc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqLoginUc) */ {
 public:
  ReqLoginUc();
  virtual ~ReqLoginUc();

  ReqLoginUc(const ReqLoginUc& from);

  inline ReqLoginUc& operator=(const ReqLoginUc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqLoginUc(ReqLoginUc&& from) noexcept
    : ReqLoginUc() {
    *this = ::std::move(from);
  }

  inline ReqLoginUc& operator=(ReqLoginUc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLoginUc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqLoginUc* internal_default_instance() {
    return reinterpret_cast<const ReqLoginUc*>(
               &_ReqLoginUc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ReqLoginUc* other);
  friend void swap(ReqLoginUc& a, ReqLoginUc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqLoginUc* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqLoginUc>(NULL);
  }

  ReqLoginUc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqLoginUc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqLoginUc& from);
  void MergeFrom(const ReqLoginUc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqLoginUc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.game.Player player = 2;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 2;
  const ::proto::game::Player& player() const;
  ::proto::game::Player* release_player();
  ::proto::game::Player* mutable_player();
  void set_allocated_player(::proto::game::Player* player);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqLoginUc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::game::Player* player_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqLoginUcImpl();
};
// -------------------------------------------------------------------

class ReqLogout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqLogout) */ {
 public:
  ReqLogout();
  virtual ~ReqLogout();

  ReqLogout(const ReqLogout& from);

  inline ReqLogout& operator=(const ReqLogout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqLogout(ReqLogout&& from) noexcept
    : ReqLogout() {
    *this = ::std::move(from);
  }

  inline ReqLogout& operator=(ReqLogout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLogout& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqLogout* internal_default_instance() {
    return reinterpret_cast<const ReqLogout*>(
               &_ReqLogout_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ReqLogout* other);
  friend void swap(ReqLogout& a, ReqLogout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqLogout* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqLogout>(NULL);
  }

  ReqLogout* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqLogout>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqLogout& from);
  void MergeFrom(const ReqLogout& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqLogout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.game.Player player = 1;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 1;
  const ::proto::game::Player& player() const;
  ::proto::game::Player* release_player();
  ::proto::game::Player* mutable_player();
  void set_allocated_player(::proto::game::Player* player);

  // @@protoc_insertion_point(class_scope:proto.game.ReqLogout)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::game::Player* player_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqLogoutImpl();
};
// -------------------------------------------------------------------

class ReqLogoutUc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqLogoutUc) */ {
 public:
  ReqLogoutUc();
  virtual ~ReqLogoutUc();

  ReqLogoutUc(const ReqLogoutUc& from);

  inline ReqLogoutUc& operator=(const ReqLogoutUc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqLogoutUc(ReqLogoutUc&& from) noexcept
    : ReqLogoutUc() {
    *this = ::std::move(from);
  }

  inline ReqLogoutUc& operator=(ReqLogoutUc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLogoutUc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqLogoutUc* internal_default_instance() {
    return reinterpret_cast<const ReqLogoutUc*>(
               &_ReqLogoutUc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ReqLogoutUc* other);
  friend void swap(ReqLogoutUc& a, ReqLogoutUc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqLogoutUc* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqLogoutUc>(NULL);
  }

  ReqLogoutUc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqLogoutUc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqLogoutUc& from);
  void MergeFrom(const ReqLogoutUc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqLogoutUc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string remark = 2;
  void clear_remark();
  static const int kRemarkFieldNumber = 2;
  const ::std::string& remark() const;
  void set_remark(const ::std::string& value);
  #if LANG_CXX11
  void set_remark(::std::string&& value);
  #endif
  void set_remark(const char* value);
  void set_remark(const char* value, size_t size);
  ::std::string* mutable_remark();
  ::std::string* release_remark();
  void set_allocated_remark(::std::string* remark);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqLogoutUc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr remark_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqLogoutUcImpl();
};
// -------------------------------------------------------------------

class ReqRegist : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqRegist) */ {
 public:
  ReqRegist();
  virtual ~ReqRegist();

  ReqRegist(const ReqRegist& from);

  inline ReqRegist& operator=(const ReqRegist& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqRegist(ReqRegist&& from) noexcept
    : ReqRegist() {
    *this = ::std::move(from);
  }

  inline ReqRegist& operator=(ReqRegist&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqRegist& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqRegist* internal_default_instance() {
    return reinterpret_cast<const ReqRegist*>(
               &_ReqRegist_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ReqRegist* other);
  friend void swap(ReqRegist& a, ReqRegist& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqRegist* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqRegist>(NULL);
  }

  ReqRegist* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqRegist>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqRegist& from);
  void MergeFrom(const ReqRegist& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqRegist* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.game.Player player = 1;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 1;
  const ::proto::game::Player& player() const;
  ::proto::game::Player* release_player();
  ::proto::game::Player* mutable_player();
  void set_allocated_player(::proto::game::Player* player);

  // @@protoc_insertion_point(class_scope:proto.game.ReqRegist)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::game::Player* player_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqRegistImpl();
};
// -------------------------------------------------------------------

class ReqRegistUc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqRegistUc) */ {
 public:
  ReqRegistUc();
  virtual ~ReqRegistUc();

  ReqRegistUc(const ReqRegistUc& from);

  inline ReqRegistUc& operator=(const ReqRegistUc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqRegistUc(ReqRegistUc&& from) noexcept
    : ReqRegistUc() {
    *this = ::std::move(from);
  }

  inline ReqRegistUc& operator=(ReqRegistUc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqRegistUc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqRegistUc* internal_default_instance() {
    return reinterpret_cast<const ReqRegistUc*>(
               &_ReqRegistUc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ReqRegistUc* other);
  friend void swap(ReqRegistUc& a, ReqRegistUc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqRegistUc* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqRegistUc>(NULL);
  }

  ReqRegistUc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqRegistUc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqRegistUc& from);
  void MergeFrom(const ReqRegistUc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqRegistUc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.game.Player player = 2;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 2;
  const ::proto::game::Player& player() const;
  ::proto::game::Player* release_player();
  ::proto::game::Player* mutable_player();
  void set_allocated_player(::proto::game::Player* player);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqRegistUc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::game::Player* player_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqRegistUcImpl();
};
// -------------------------------------------------------------------

class ReqUpdatePwd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqUpdatePwd) */ {
 public:
  ReqUpdatePwd();
  virtual ~ReqUpdatePwd();

  ReqUpdatePwd(const ReqUpdatePwd& from);

  inline ReqUpdatePwd& operator=(const ReqUpdatePwd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqUpdatePwd(ReqUpdatePwd&& from) noexcept
    : ReqUpdatePwd() {
    *this = ::std::move(from);
  }

  inline ReqUpdatePwd& operator=(ReqUpdatePwd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqUpdatePwd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqUpdatePwd* internal_default_instance() {
    return reinterpret_cast<const ReqUpdatePwd*>(
               &_ReqUpdatePwd_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ReqUpdatePwd* other);
  friend void swap(ReqUpdatePwd& a, ReqUpdatePwd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqUpdatePwd* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqUpdatePwd>(NULL);
  }

  ReqUpdatePwd* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqUpdatePwd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqUpdatePwd& from);
  void MergeFrom(const ReqUpdatePwd& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqUpdatePwd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account = 1;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // string oldpasswd = 2;
  void clear_oldpasswd();
  static const int kOldpasswdFieldNumber = 2;
  const ::std::string& oldpasswd() const;
  void set_oldpasswd(const ::std::string& value);
  #if LANG_CXX11
  void set_oldpasswd(::std::string&& value);
  #endif
  void set_oldpasswd(const char* value);
  void set_oldpasswd(const char* value, size_t size);
  ::std::string* mutable_oldpasswd();
  ::std::string* release_oldpasswd();
  void set_allocated_oldpasswd(::std::string* oldpasswd);

  // string newpasswd = 3;
  void clear_newpasswd();
  static const int kNewpasswdFieldNumber = 3;
  const ::std::string& newpasswd() const;
  void set_newpasswd(const ::std::string& value);
  #if LANG_CXX11
  void set_newpasswd(::std::string&& value);
  #endif
  void set_newpasswd(const char* value);
  void set_newpasswd(const char* value, size_t size);
  ::std::string* mutable_newpasswd();
  ::std::string* release_newpasswd();
  void set_allocated_newpasswd(::std::string* newpasswd);

  // @@protoc_insertion_point(class_scope:proto.game.ReqUpdatePwd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::internal::ArenaStringPtr oldpasswd_;
  ::google::protobuf::internal::ArenaStringPtr newpasswd_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqUpdatePwdImpl();
};
// -------------------------------------------------------------------

class ReqUpdatePwdUc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqUpdatePwdUc) */ {
 public:
  ReqUpdatePwdUc();
  virtual ~ReqUpdatePwdUc();

  ReqUpdatePwdUc(const ReqUpdatePwdUc& from);

  inline ReqUpdatePwdUc& operator=(const ReqUpdatePwdUc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqUpdatePwdUc(ReqUpdatePwdUc&& from) noexcept
    : ReqUpdatePwdUc() {
    *this = ::std::move(from);
  }

  inline ReqUpdatePwdUc& operator=(ReqUpdatePwdUc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqUpdatePwdUc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqUpdatePwdUc* internal_default_instance() {
    return reinterpret_cast<const ReqUpdatePwdUc*>(
               &_ReqUpdatePwdUc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ReqUpdatePwdUc* other);
  friend void swap(ReqUpdatePwdUc& a, ReqUpdatePwdUc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqUpdatePwdUc* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqUpdatePwdUc>(NULL);
  }

  ReqUpdatePwdUc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqUpdatePwdUc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqUpdatePwdUc& from);
  void MergeFrom(const ReqUpdatePwdUc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqUpdatePwdUc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqUpdatePwdUc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqUpdatePwdUcImpl();
};
// -------------------------------------------------------------------

class ReqGetFriends : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqGetFriends) */ {
 public:
  ReqGetFriends();
  virtual ~ReqGetFriends();

  ReqGetFriends(const ReqGetFriends& from);

  inline ReqGetFriends& operator=(const ReqGetFriends& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqGetFriends(ReqGetFriends&& from) noexcept
    : ReqGetFriends() {
    *this = ::std::move(from);
  }

  inline ReqGetFriends& operator=(ReqGetFriends&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGetFriends& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqGetFriends* internal_default_instance() {
    return reinterpret_cast<const ReqGetFriends*>(
               &_ReqGetFriends_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ReqGetFriends* other);
  friend void swap(ReqGetFriends& a, ReqGetFriends& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqGetFriends* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqGetFriends>(NULL);
  }

  ReqGetFriends* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqGetFriends>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqGetFriends& from);
  void MergeFrom(const ReqGetFriends& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqGetFriends* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.game.ReqGetFriends)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqGetFriendsImpl();
};
// -------------------------------------------------------------------

class ReqGetFriendsUc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqGetFriendsUc) */ {
 public:
  ReqGetFriendsUc();
  virtual ~ReqGetFriendsUc();

  ReqGetFriendsUc(const ReqGetFriendsUc& from);

  inline ReqGetFriendsUc& operator=(const ReqGetFriendsUc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqGetFriendsUc(ReqGetFriendsUc&& from) noexcept
    : ReqGetFriendsUc() {
    *this = ::std::move(from);
  }

  inline ReqGetFriendsUc& operator=(ReqGetFriendsUc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGetFriendsUc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqGetFriendsUc* internal_default_instance() {
    return reinterpret_cast<const ReqGetFriendsUc*>(
               &_ReqGetFriendsUc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ReqGetFriendsUc* other);
  friend void swap(ReqGetFriendsUc& a, ReqGetFriendsUc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqGetFriendsUc* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqGetFriendsUc>(NULL);
  }

  ReqGetFriendsUc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqGetFriendsUc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqGetFriendsUc& from);
  void MergeFrom(const ReqGetFriendsUc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqGetFriendsUc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.game.Player frieds = 2;
  int frieds_size() const;
  void clear_frieds();
  static const int kFriedsFieldNumber = 2;
  ::proto::game::Player* mutable_frieds(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::game::Player >*
      mutable_frieds();
  const ::proto::game::Player& frieds(int index) const;
  ::proto::game::Player* add_frieds();
  const ::google::protobuf::RepeatedPtrField< ::proto::game::Player >&
      frieds() const;

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqGetFriendsUc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::game::Player > frieds_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqGetFriendsUcImpl();
};
// -------------------------------------------------------------------

class ReqAddFriends : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqAddFriends) */ {
 public:
  ReqAddFriends();
  virtual ~ReqAddFriends();

  ReqAddFriends(const ReqAddFriends& from);

  inline ReqAddFriends& operator=(const ReqAddFriends& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqAddFriends(ReqAddFriends&& from) noexcept
    : ReqAddFriends() {
    *this = ::std::move(from);
  }

  inline ReqAddFriends& operator=(ReqAddFriends&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAddFriends& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqAddFriends* internal_default_instance() {
    return reinterpret_cast<const ReqAddFriends*>(
               &_ReqAddFriends_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ReqAddFriends* other);
  friend void swap(ReqAddFriends& a, ReqAddFriends& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqAddFriends* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqAddFriends>(NULL);
  }

  ReqAddFriends* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqAddFriends>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqAddFriends& from);
  void MergeFrom(const ReqAddFriends& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqAddFriends* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.game.Player friend = 1;
  bool has_friend_() const;
  void clear_friend_();
  static const int kFriendFieldNumber = 1;
  const ::proto::game::Player& friend_() const;
  ::proto::game::Player* release_friend_();
  ::proto::game::Player* mutable_friend_();
  void set_allocated_friend_(::proto::game::Player* friend_);

  // @@protoc_insertion_point(class_scope:proto.game.ReqAddFriends)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::game::Player* friend__;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqAddFriendsImpl();
};
// -------------------------------------------------------------------

class ReqAddFriendsUc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqAddFriendsUc) */ {
 public:
  ReqAddFriendsUc();
  virtual ~ReqAddFriendsUc();

  ReqAddFriendsUc(const ReqAddFriendsUc& from);

  inline ReqAddFriendsUc& operator=(const ReqAddFriendsUc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqAddFriendsUc(ReqAddFriendsUc&& from) noexcept
    : ReqAddFriendsUc() {
    *this = ::std::move(from);
  }

  inline ReqAddFriendsUc& operator=(ReqAddFriendsUc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAddFriendsUc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqAddFriendsUc* internal_default_instance() {
    return reinterpret_cast<const ReqAddFriendsUc*>(
               &_ReqAddFriendsUc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ReqAddFriendsUc* other);
  friend void swap(ReqAddFriendsUc& a, ReqAddFriendsUc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqAddFriendsUc* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqAddFriendsUc>(NULL);
  }

  ReqAddFriendsUc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqAddFriendsUc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqAddFriendsUc& from);
  void MergeFrom(const ReqAddFriendsUc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqAddFriendsUc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.game.Player friend = 2;
  bool has_friend_() const;
  void clear_friend_();
  static const int kFriendFieldNumber = 2;
  const ::proto::game::Player& friend_() const;
  ::proto::game::Player* release_friend_();
  ::proto::game::Player* mutable_friend_();
  void set_allocated_friend_(::proto::game::Player* friend_);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqAddFriendsUc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::game::Player* friend__;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqAddFriendsUcImpl();
};
// -------------------------------------------------------------------

class ReqDeleteFriend : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqDeleteFriend) */ {
 public:
  ReqDeleteFriend();
  virtual ~ReqDeleteFriend();

  ReqDeleteFriend(const ReqDeleteFriend& from);

  inline ReqDeleteFriend& operator=(const ReqDeleteFriend& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqDeleteFriend(ReqDeleteFriend&& from) noexcept
    : ReqDeleteFriend() {
    *this = ::std::move(from);
  }

  inline ReqDeleteFriend& operator=(ReqDeleteFriend&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqDeleteFriend& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqDeleteFriend* internal_default_instance() {
    return reinterpret_cast<const ReqDeleteFriend*>(
               &_ReqDeleteFriend_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ReqDeleteFriend* other);
  friend void swap(ReqDeleteFriend& a, ReqDeleteFriend& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqDeleteFriend* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqDeleteFriend>(NULL);
  }

  ReqDeleteFriend* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqDeleteFriend>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqDeleteFriend& from);
  void MergeFrom(const ReqDeleteFriend& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqDeleteFriend* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.game.Player friend = 1;
  bool has_friend_() const;
  void clear_friend_();
  static const int kFriendFieldNumber = 1;
  const ::proto::game::Player& friend_() const;
  ::proto::game::Player* release_friend_();
  ::proto::game::Player* mutable_friend_();
  void set_allocated_friend_(::proto::game::Player* friend_);

  // @@protoc_insertion_point(class_scope:proto.game.ReqDeleteFriend)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::game::Player* friend__;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqDeleteFriendImpl();
};
// -------------------------------------------------------------------

class ReqDeleteFriendUc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqDeleteFriendUc) */ {
 public:
  ReqDeleteFriendUc();
  virtual ~ReqDeleteFriendUc();

  ReqDeleteFriendUc(const ReqDeleteFriendUc& from);

  inline ReqDeleteFriendUc& operator=(const ReqDeleteFriendUc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqDeleteFriendUc(ReqDeleteFriendUc&& from) noexcept
    : ReqDeleteFriendUc() {
    *this = ::std::move(from);
  }

  inline ReqDeleteFriendUc& operator=(ReqDeleteFriendUc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqDeleteFriendUc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqDeleteFriendUc* internal_default_instance() {
    return reinterpret_cast<const ReqDeleteFriendUc*>(
               &_ReqDeleteFriendUc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(ReqDeleteFriendUc* other);
  friend void swap(ReqDeleteFriendUc& a, ReqDeleteFriendUc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqDeleteFriendUc* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqDeleteFriendUc>(NULL);
  }

  ReqDeleteFriendUc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqDeleteFriendUc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqDeleteFriendUc& from);
  void MergeFrom(const ReqDeleteFriendUc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqDeleteFriendUc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 code = 2;
  void clear_code();
  static const int kCodeFieldNumber = 2;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqDeleteFriendUc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqDeleteFriendUcImpl();
};
// -------------------------------------------------------------------

class Room : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.Room) */ {
 public:
  Room();
  virtual ~Room();

  Room(const Room& from);

  inline Room& operator=(const Room& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Room(Room&& from) noexcept
    : Room() {
    *this = ::std::move(from);
  }

  inline Room& operator=(Room&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Room& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Room* internal_default_instance() {
    return reinterpret_cast<const Room*>(
               &_Room_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Room* other);
  friend void swap(Room& a, Room& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Room* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Room>(NULL);
  }

  Room* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Room>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Room& from);
  void MergeFrom(const Room& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Room* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.game.Player players = 8;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 8;
  ::proto::game::Player* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::game::Player >*
      mutable_players();
  const ::proto::game::Player& players(int index) const;
  ::proto::game::Player* add_players();
  const ::google::protobuf::RepeatedPtrField< ::proto::game::Player >&
      players() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .proto.game.Player master = 9;
  bool has_master() const;
  void clear_master();
  static const int kMasterFieldNumber = 9;
  const ::proto::game::Player& master() const;
  ::proto::game::Player* release_master();
  ::proto::game::Player* mutable_master();
  void set_allocated_master(::proto::game::Player* master);

  // int32 room_id = 1;
  void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  ::google::protobuf::int32 room_id() const;
  void set_room_id(::google::protobuf::int32 value);

  // int32 type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // int32 max_player_cnt = 4;
  void clear_max_player_cnt();
  static const int kMaxPlayerCntFieldNumber = 4;
  ::google::protobuf::int32 max_player_cnt() const;
  void set_max_player_cnt(::google::protobuf::int32 value);

  // int32 player_cnt = 5;
  void clear_player_cnt();
  static const int kPlayerCntFieldNumber = 5;
  ::google::protobuf::int32 player_cnt() const;
  void set_player_cnt(::google::protobuf::int32 value);

  // int32 match_seat_way = 6;
  void clear_match_seat_way();
  static const int kMatchSeatWayFieldNumber = 6;
  ::google::protobuf::int32 match_seat_way() const;
  void set_match_seat_way(::google::protobuf::int32 value);

  // int32 status = 7;
  void clear_status();
  static const int kStatusFieldNumber = 7;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.Room)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::game::Player > players_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::proto::game::Player* master_;
  ::google::protobuf::int32 room_id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 max_player_cnt_;
  ::google::protobuf::int32 player_cnt_;
  ::google::protobuf::int32 match_seat_way_;
  ::google::protobuf::int32 status_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsRoomImpl();
};
// -------------------------------------------------------------------

class ReqCreateRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqCreateRoom) */ {
 public:
  ReqCreateRoom();
  virtual ~ReqCreateRoom();

  ReqCreateRoom(const ReqCreateRoom& from);

  inline ReqCreateRoom& operator=(const ReqCreateRoom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqCreateRoom(ReqCreateRoom&& from) noexcept
    : ReqCreateRoom() {
    *this = ::std::move(from);
  }

  inline ReqCreateRoom& operator=(ReqCreateRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCreateRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqCreateRoom* internal_default_instance() {
    return reinterpret_cast<const ReqCreateRoom*>(
               &_ReqCreateRoom_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(ReqCreateRoom* other);
  friend void swap(ReqCreateRoom& a, ReqCreateRoom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqCreateRoom* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqCreateRoom>(NULL);
  }

  ReqCreateRoom* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqCreateRoom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqCreateRoom& from);
  void MergeFrom(const ReqCreateRoom& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqCreateRoom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.game.Room room = 1;
  bool has_room() const;
  void clear_room();
  static const int kRoomFieldNumber = 1;
  const ::proto::game::Room& room() const;
  ::proto::game::Room* release_room();
  ::proto::game::Room* mutable_room();
  void set_allocated_room(::proto::game::Room* room);

  // @@protoc_insertion_point(class_scope:proto.game.ReqCreateRoom)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::game::Room* room_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqCreateRoomImpl();
};
// -------------------------------------------------------------------

class ReqCreateRoomUc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqCreateRoomUc) */ {
 public:
  ReqCreateRoomUc();
  virtual ~ReqCreateRoomUc();

  ReqCreateRoomUc(const ReqCreateRoomUc& from);

  inline ReqCreateRoomUc& operator=(const ReqCreateRoomUc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqCreateRoomUc(ReqCreateRoomUc&& from) noexcept
    : ReqCreateRoomUc() {
    *this = ::std::move(from);
  }

  inline ReqCreateRoomUc& operator=(ReqCreateRoomUc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCreateRoomUc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqCreateRoomUc* internal_default_instance() {
    return reinterpret_cast<const ReqCreateRoomUc*>(
               &_ReqCreateRoomUc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(ReqCreateRoomUc* other);
  friend void swap(ReqCreateRoomUc& a, ReqCreateRoomUc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqCreateRoomUc* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqCreateRoomUc>(NULL);
  }

  ReqCreateRoomUc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqCreateRoomUc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqCreateRoomUc& from);
  void MergeFrom(const ReqCreateRoomUc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqCreateRoomUc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.game.Room room = 2;
  bool has_room() const;
  void clear_room();
  static const int kRoomFieldNumber = 2;
  const ::proto::game::Room& room() const;
  ::proto::game::Room* release_room();
  ::proto::game::Room* mutable_room();
  void set_allocated_room(::proto::game::Room* room);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqCreateRoomUc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::game::Room* room_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqCreateRoomUcImpl();
};
// -------------------------------------------------------------------

class ReqSearchRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqSearchRoom) */ {
 public:
  ReqSearchRoom();
  virtual ~ReqSearchRoom();

  ReqSearchRoom(const ReqSearchRoom& from);

  inline ReqSearchRoom& operator=(const ReqSearchRoom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqSearchRoom(ReqSearchRoom&& from) noexcept
    : ReqSearchRoom() {
    *this = ::std::move(from);
  }

  inline ReqSearchRoom& operator=(ReqSearchRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSearchRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqSearchRoom* internal_default_instance() {
    return reinterpret_cast<const ReqSearchRoom*>(
               &_ReqSearchRoom_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(ReqSearchRoom* other);
  friend void swap(ReqSearchRoom& a, ReqSearchRoom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqSearchRoom* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqSearchRoom>(NULL);
  }

  ReqSearchRoom* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqSearchRoom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqSearchRoom& from);
  void MergeFrom(const ReqSearchRoom& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqSearchRoom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 roomid = 1;
  void clear_roomid();
  static const int kRoomidFieldNumber = 1;
  ::google::protobuf::int32 roomid() const;
  void set_roomid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqSearchRoom)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 roomid_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqSearchRoomImpl();
};
// -------------------------------------------------------------------

class ReqSearchRoomUc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqSearchRoomUc) */ {
 public:
  ReqSearchRoomUc();
  virtual ~ReqSearchRoomUc();

  ReqSearchRoomUc(const ReqSearchRoomUc& from);

  inline ReqSearchRoomUc& operator=(const ReqSearchRoomUc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqSearchRoomUc(ReqSearchRoomUc&& from) noexcept
    : ReqSearchRoomUc() {
    *this = ::std::move(from);
  }

  inline ReqSearchRoomUc& operator=(ReqSearchRoomUc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSearchRoomUc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqSearchRoomUc* internal_default_instance() {
    return reinterpret_cast<const ReqSearchRoomUc*>(
               &_ReqSearchRoomUc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(ReqSearchRoomUc* other);
  friend void swap(ReqSearchRoomUc& a, ReqSearchRoomUc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqSearchRoomUc* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqSearchRoomUc>(NULL);
  }

  ReqSearchRoomUc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqSearchRoomUc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqSearchRoomUc& from);
  void MergeFrom(const ReqSearchRoomUc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqSearchRoomUc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.game.Room room = 2;
  bool has_room() const;
  void clear_room();
  static const int kRoomFieldNumber = 2;
  const ::proto::game::Room& room() const;
  ::proto::game::Room* release_room();
  ::proto::game::Room* mutable_room();
  void set_allocated_room(::proto::game::Room* room);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqSearchRoomUc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::game::Room* room_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqSearchRoomUcImpl();
};
// -------------------------------------------------------------------

class ReqEnterRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqEnterRoom) */ {
 public:
  ReqEnterRoom();
  virtual ~ReqEnterRoom();

  ReqEnterRoom(const ReqEnterRoom& from);

  inline ReqEnterRoom& operator=(const ReqEnterRoom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqEnterRoom(ReqEnterRoom&& from) noexcept
    : ReqEnterRoom() {
    *this = ::std::move(from);
  }

  inline ReqEnterRoom& operator=(ReqEnterRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqEnterRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqEnterRoom* internal_default_instance() {
    return reinterpret_cast<const ReqEnterRoom*>(
               &_ReqEnterRoom_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(ReqEnterRoom* other);
  friend void swap(ReqEnterRoom& a, ReqEnterRoom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqEnterRoom* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqEnterRoom>(NULL);
  }

  ReqEnterRoom* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqEnterRoom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqEnterRoom& from);
  void MergeFrom(const ReqEnterRoom& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqEnterRoom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 roomid = 1;
  void clear_roomid();
  static const int kRoomidFieldNumber = 1;
  ::google::protobuf::int32 roomid() const;
  void set_roomid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqEnterRoom)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 roomid_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqEnterRoomImpl();
};
// -------------------------------------------------------------------

class ReqEnterRoomFast : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqEnterRoomFast) */ {
 public:
  ReqEnterRoomFast();
  virtual ~ReqEnterRoomFast();

  ReqEnterRoomFast(const ReqEnterRoomFast& from);

  inline ReqEnterRoomFast& operator=(const ReqEnterRoomFast& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqEnterRoomFast(ReqEnterRoomFast&& from) noexcept
    : ReqEnterRoomFast() {
    *this = ::std::move(from);
  }

  inline ReqEnterRoomFast& operator=(ReqEnterRoomFast&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqEnterRoomFast& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqEnterRoomFast* internal_default_instance() {
    return reinterpret_cast<const ReqEnterRoomFast*>(
               &_ReqEnterRoomFast_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(ReqEnterRoomFast* other);
  friend void swap(ReqEnterRoomFast& a, ReqEnterRoomFast& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqEnterRoomFast* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqEnterRoomFast>(NULL);
  }

  ReqEnterRoomFast* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqEnterRoomFast>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqEnterRoomFast& from);
  void MergeFrom(const ReqEnterRoomFast& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqEnterRoomFast* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.game.ReqEnterRoomFast)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqEnterRoomFastImpl();
};
// -------------------------------------------------------------------

class ReqEnterRoomBc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqEnterRoomBc) */ {
 public:
  ReqEnterRoomBc();
  virtual ~ReqEnterRoomBc();

  ReqEnterRoomBc(const ReqEnterRoomBc& from);

  inline ReqEnterRoomBc& operator=(const ReqEnterRoomBc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqEnterRoomBc(ReqEnterRoomBc&& from) noexcept
    : ReqEnterRoomBc() {
    *this = ::std::move(from);
  }

  inline ReqEnterRoomBc& operator=(ReqEnterRoomBc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqEnterRoomBc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqEnterRoomBc* internal_default_instance() {
    return reinterpret_cast<const ReqEnterRoomBc*>(
               &_ReqEnterRoomBc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(ReqEnterRoomBc* other);
  friend void swap(ReqEnterRoomBc& a, ReqEnterRoomBc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqEnterRoomBc* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqEnterRoomBc>(NULL);
  }

  ReqEnterRoomBc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqEnterRoomBc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqEnterRoomBc& from);
  void MergeFrom(const ReqEnterRoomBc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqEnterRoomBc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.game.Player player = 2;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 2;
  const ::proto::game::Player& player() const;
  ::proto::game::Player* release_player();
  ::proto::game::Player* mutable_player();
  void set_allocated_player(::proto::game::Player* player);

  // .proto.game.Room room = 3;
  bool has_room() const;
  void clear_room();
  static const int kRoomFieldNumber = 3;
  const ::proto::game::Room& room() const;
  ::proto::game::Room* release_room();
  ::proto::game::Room* mutable_room();
  void set_allocated_room(::proto::game::Room* room);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqEnterRoomBc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::game::Player* player_;
  ::proto::game::Room* room_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqEnterRoomBcImpl();
};
// -------------------------------------------------------------------

class ReqQuitRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqQuitRoom) */ {
 public:
  ReqQuitRoom();
  virtual ~ReqQuitRoom();

  ReqQuitRoom(const ReqQuitRoom& from);

  inline ReqQuitRoom& operator=(const ReqQuitRoom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqQuitRoom(ReqQuitRoom&& from) noexcept
    : ReqQuitRoom() {
    *this = ::std::move(from);
  }

  inline ReqQuitRoom& operator=(ReqQuitRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqQuitRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqQuitRoom* internal_default_instance() {
    return reinterpret_cast<const ReqQuitRoom*>(
               &_ReqQuitRoom_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(ReqQuitRoom* other);
  friend void swap(ReqQuitRoom& a, ReqQuitRoom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqQuitRoom* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqQuitRoom>(NULL);
  }

  ReqQuitRoom* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqQuitRoom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqQuitRoom& from);
  void MergeFrom(const ReqQuitRoom& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqQuitRoom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 roomid = 1;
  void clear_roomid();
  static const int kRoomidFieldNumber = 1;
  ::google::protobuf::int32 roomid() const;
  void set_roomid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqQuitRoom)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 roomid_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqQuitRoomImpl();
};
// -------------------------------------------------------------------

class ReqQuitRoomBc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqQuitRoomBc) */ {
 public:
  ReqQuitRoomBc();
  virtual ~ReqQuitRoomBc();

  ReqQuitRoomBc(const ReqQuitRoomBc& from);

  inline ReqQuitRoomBc& operator=(const ReqQuitRoomBc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqQuitRoomBc(ReqQuitRoomBc&& from) noexcept
    : ReqQuitRoomBc() {
    *this = ::std::move(from);
  }

  inline ReqQuitRoomBc& operator=(ReqQuitRoomBc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqQuitRoomBc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqQuitRoomBc* internal_default_instance() {
    return reinterpret_cast<const ReqQuitRoomBc*>(
               &_ReqQuitRoomBc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(ReqQuitRoomBc* other);
  friend void swap(ReqQuitRoomBc& a, ReqQuitRoomBc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqQuitRoomBc* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqQuitRoomBc>(NULL);
  }

  ReqQuitRoomBc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqQuitRoomBc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqQuitRoomBc& from);
  void MergeFrom(const ReqQuitRoomBc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqQuitRoomBc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.game.Player player = 2;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 2;
  const ::proto::game::Player& player() const;
  ::proto::game::Player* release_player();
  ::proto::game::Player* mutable_player();
  void set_allocated_player(::proto::game::Player* player);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqQuitRoomBc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::game::Player* player_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqQuitRoomBcImpl();
};
// -------------------------------------------------------------------

class ReqReady : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqReady) */ {
 public:
  ReqReady();
  virtual ~ReqReady();

  ReqReady(const ReqReady& from);

  inline ReqReady& operator=(const ReqReady& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqReady(ReqReady&& from) noexcept
    : ReqReady() {
    *this = ::std::move(from);
  }

  inline ReqReady& operator=(ReqReady&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqReady& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqReady* internal_default_instance() {
    return reinterpret_cast<const ReqReady*>(
               &_ReqReady_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(ReqReady* other);
  friend void swap(ReqReady& a, ReqReady& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqReady* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqReady>(NULL);
  }

  ReqReady* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqReady>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqReady& from);
  void MergeFrom(const ReqReady& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqReady* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 roomid = 1;
  void clear_roomid();
  static const int kRoomidFieldNumber = 1;
  ::google::protobuf::int32 roomid() const;
  void set_roomid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqReady)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 roomid_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqReadyImpl();
};
// -------------------------------------------------------------------

class ReqReadyBc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqReadyBc) */ {
 public:
  ReqReadyBc();
  virtual ~ReqReadyBc();

  ReqReadyBc(const ReqReadyBc& from);

  inline ReqReadyBc& operator=(const ReqReadyBc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqReadyBc(ReqReadyBc&& from) noexcept
    : ReqReadyBc() {
    *this = ::std::move(from);
  }

  inline ReqReadyBc& operator=(ReqReadyBc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqReadyBc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqReadyBc* internal_default_instance() {
    return reinterpret_cast<const ReqReadyBc*>(
               &_ReqReadyBc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(ReqReadyBc* other);
  friend void swap(ReqReadyBc& a, ReqReadyBc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqReadyBc* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqReadyBc>(NULL);
  }

  ReqReadyBc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqReadyBc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqReadyBc& from);
  void MergeFrom(const ReqReadyBc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqReadyBc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.game.Player player = 2;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 2;
  const ::proto::game::Player& player() const;
  ::proto::game::Player* release_player();
  ::proto::game::Player* mutable_player();
  void set_allocated_player(::proto::game::Player* player);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqReadyBc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::game::Player* player_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqReadyBcImpl();
};
// -------------------------------------------------------------------

class ReqEmotionBC : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.game.ReqEmotionBC) */ {
 public:
  ReqEmotionBC();
  virtual ~ReqEmotionBC();

  ReqEmotionBC(const ReqEmotionBC& from);

  inline ReqEmotionBC& operator=(const ReqEmotionBC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqEmotionBC(ReqEmotionBC&& from) noexcept
    : ReqEmotionBC() {
    *this = ::std::move(from);
  }

  inline ReqEmotionBC& operator=(ReqEmotionBC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqEmotionBC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqEmotionBC* internal_default_instance() {
    return reinterpret_cast<const ReqEmotionBC*>(
               &_ReqEmotionBC_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(ReqEmotionBC* other);
  friend void swap(ReqEmotionBC& a, ReqEmotionBC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqEmotionBC* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqEmotionBC>(NULL);
  }

  ReqEmotionBC* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ReqEmotionBC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqEmotionBC& from);
  void MergeFrom(const ReqEmotionBC& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqEmotionBC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 seatid = 1;
  void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  ::google::protobuf::int32 seatid() const;
  void set_seatid(::google::protobuf::int32 value);

  // int32 type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqEmotionBC)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 type_;
  mutable int _cached_size_;
  friend struct ::protobuf_appproto_2eproto::TableStruct;
  friend void ::protobuf_appproto_2eproto::InitDefaultsReqEmotionBCImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Player

// int32 id = 1;
inline void Player::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Player::id() const {
  // @@protoc_insertion_point(field_get:proto.game.Player.id)
  return id_;
}
inline void Player::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:proto.game.Player.id)
}

// string account = 2;
inline void Player::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Player::account() const {
  // @@protoc_insertion_point(field_get:proto.game.Player.account)
  return account_.GetNoArena();
}
inline void Player::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.game.Player.account)
}
#if LANG_CXX11
inline void Player::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.game.Player.account)
}
#endif
inline void Player::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.game.Player.account)
}
inline void Player::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.game.Player.account)
}
inline ::std::string* Player::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:proto.game.Player.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_account() {
  // @@protoc_insertion_point(field_release:proto.game.Player.account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:proto.game.Player.account)
}

// string passwd = 3;
inline void Player::clear_passwd() {
  passwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Player::passwd() const {
  // @@protoc_insertion_point(field_get:proto.game.Player.passwd)
  return passwd_.GetNoArena();
}
inline void Player::set_passwd(const ::std::string& value) {
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.game.Player.passwd)
}
#if LANG_CXX11
inline void Player::set_passwd(::std::string&& value) {
  
  passwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.game.Player.passwd)
}
#endif
inline void Player::set_passwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.game.Player.passwd)
}
inline void Player::set_passwd(const char* value, size_t size) {
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.game.Player.passwd)
}
inline ::std::string* Player::mutable_passwd() {
  
  // @@protoc_insertion_point(field_mutable:proto.game.Player.passwd)
  return passwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_passwd() {
  // @@protoc_insertion_point(field_release:proto.game.Player.passwd)
  
  return passwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_passwd(::std::string* passwd) {
  if (passwd != NULL) {
    
  } else {
    
  }
  passwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passwd);
  // @@protoc_insertion_point(field_set_allocated:proto.game.Player.passwd)
}

// string name = 4;
inline void Player::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:proto.game.Player.name)
  return name_.GetNoArena();
}
inline void Player::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.game.Player.name)
}
#if LANG_CXX11
inline void Player::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.game.Player.name)
}
#endif
inline void Player::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.game.Player.name)
}
inline void Player::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.game.Player.name)
}
inline ::std::string* Player::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.game.Player.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_name() {
  // @@protoc_insertion_point(field_release:proto.game.Player.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.game.Player.name)
}

// string avatar = 5;
inline void Player::clear_avatar() {
  avatar_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Player::avatar() const {
  // @@protoc_insertion_point(field_get:proto.game.Player.avatar)
  return avatar_.GetNoArena();
}
inline void Player::set_avatar(const ::std::string& value) {
  
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.game.Player.avatar)
}
#if LANG_CXX11
inline void Player::set_avatar(::std::string&& value) {
  
  avatar_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.game.Player.avatar)
}
#endif
inline void Player::set_avatar(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.game.Player.avatar)
}
inline void Player::set_avatar(const char* value, size_t size) {
  
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.game.Player.avatar)
}
inline ::std::string* Player::mutable_avatar() {
  
  // @@protoc_insertion_point(field_mutable:proto.game.Player.avatar)
  return avatar_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_avatar() {
  // @@protoc_insertion_point(field_release:proto.game.Player.avatar)
  
  return avatar_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_avatar(::std::string* avatar) {
  if (avatar != NULL) {
    
  } else {
    
  }
  avatar_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatar);
  // @@protoc_insertion_point(field_set_allocated:proto.game.Player.avatar)
}

// int32 sex = 6;
inline void Player::clear_sex() {
  sex_ = 0;
}
inline ::google::protobuf::int32 Player::sex() const {
  // @@protoc_insertion_point(field_get:proto.game.Player.sex)
  return sex_;
}
inline void Player::set_sex(::google::protobuf::int32 value) {
  
  sex_ = value;
  // @@protoc_insertion_point(field_set:proto.game.Player.sex)
}

// int32 exp = 7;
inline void Player::clear_exp() {
  exp_ = 0;
}
inline ::google::protobuf::int32 Player::exp() const {
  // @@protoc_insertion_point(field_get:proto.game.Player.exp)
  return exp_;
}
inline void Player::set_exp(::google::protobuf::int32 value) {
  
  exp_ = value;
  // @@protoc_insertion_point(field_set:proto.game.Player.exp)
}

// int32 level = 8;
inline void Player::clear_level() {
  level_ = 0;
}
inline ::google::protobuf::int32 Player::level() const {
  // @@protoc_insertion_point(field_get:proto.game.Player.level)
  return level_;
}
inline void Player::set_level(::google::protobuf::int32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:proto.game.Player.level)
}

// int32 status = 9;
inline void Player::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 Player::status() const {
  // @@protoc_insertion_point(field_get:proto.game.Player.status)
  return status_;
}
inline void Player::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:proto.game.Player.status)
}

// int32 gamestatus = 10;
inline void Player::clear_gamestatus() {
  gamestatus_ = 0;
}
inline ::google::protobuf::int32 Player::gamestatus() const {
  // @@protoc_insertion_point(field_get:proto.game.Player.gamestatus)
  return gamestatus_;
}
inline void Player::set_gamestatus(::google::protobuf::int32 value) {
  
  gamestatus_ = value;
  // @@protoc_insertion_point(field_set:proto.game.Player.gamestatus)
}

// int32 seatid = 11;
inline void Player::clear_seatid() {
  seatid_ = 0;
}
inline ::google::protobuf::int32 Player::seatid() const {
  // @@protoc_insertion_point(field_get:proto.game.Player.seatid)
  return seatid_;
}
inline void Player::set_seatid(::google::protobuf::int32 value) {
  
  seatid_ = value;
  // @@protoc_insertion_point(field_set:proto.game.Player.seatid)
}

// string registdate = 12;
inline void Player::clear_registdate() {
  registdate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Player::registdate() const {
  // @@protoc_insertion_point(field_get:proto.game.Player.registdate)
  return registdate_.GetNoArena();
}
inline void Player::set_registdate(const ::std::string& value) {
  
  registdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.game.Player.registdate)
}
#if LANG_CXX11
inline void Player::set_registdate(::std::string&& value) {
  
  registdate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.game.Player.registdate)
}
#endif
inline void Player::set_registdate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  registdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.game.Player.registdate)
}
inline void Player::set_registdate(const char* value, size_t size) {
  
  registdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.game.Player.registdate)
}
inline ::std::string* Player::mutable_registdate() {
  
  // @@protoc_insertion_point(field_mutable:proto.game.Player.registdate)
  return registdate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_registdate() {
  // @@protoc_insertion_point(field_release:proto.game.Player.registdate)
  
  return registdate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_registdate(::std::string* registdate) {
  if (registdate != NULL) {
    
  } else {
    
  }
  registdate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), registdate);
  // @@protoc_insertion_point(field_set_allocated:proto.game.Player.registdate)
}

// string remark = 13;
inline void Player::clear_remark() {
  remark_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Player::remark() const {
  // @@protoc_insertion_point(field_get:proto.game.Player.remark)
  return remark_.GetNoArena();
}
inline void Player::set_remark(const ::std::string& value) {
  
  remark_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.game.Player.remark)
}
#if LANG_CXX11
inline void Player::set_remark(::std::string&& value) {
  
  remark_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.game.Player.remark)
}
#endif
inline void Player::set_remark(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remark_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.game.Player.remark)
}
inline void Player::set_remark(const char* value, size_t size) {
  
  remark_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.game.Player.remark)
}
inline ::std::string* Player::mutable_remark() {
  
  // @@protoc_insertion_point(field_mutable:proto.game.Player.remark)
  return remark_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_remark() {
  // @@protoc_insertion_point(field_release:proto.game.Player.remark)
  
  return remark_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_remark(::std::string* remark) {
  if (remark != NULL) {
    
  } else {
    
  }
  remark_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remark);
  // @@protoc_insertion_point(field_set_allocated:proto.game.Player.remark)
}

// -------------------------------------------------------------------

// ReqLogin

// string account = 1;
inline void ReqLogin::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqLogin::account() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqLogin.account)
  return account_.GetNoArena();
}
inline void ReqLogin::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.game.ReqLogin.account)
}
#if LANG_CXX11
inline void ReqLogin::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.game.ReqLogin.account)
}
#endif
inline void ReqLogin::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.game.ReqLogin.account)
}
inline void ReqLogin::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.game.ReqLogin.account)
}
inline ::std::string* ReqLogin::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:proto.game.ReqLogin.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqLogin::release_account() {
  // @@protoc_insertion_point(field_release:proto.game.ReqLogin.account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqLogin::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqLogin.account)
}

// string pwd = 2;
inline void ReqLogin::clear_pwd() {
  pwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqLogin::pwd() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqLogin.pwd)
  return pwd_.GetNoArena();
}
inline void ReqLogin::set_pwd(const ::std::string& value) {
  
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.game.ReqLogin.pwd)
}
#if LANG_CXX11
inline void ReqLogin::set_pwd(::std::string&& value) {
  
  pwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.game.ReqLogin.pwd)
}
#endif
inline void ReqLogin::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.game.ReqLogin.pwd)
}
inline void ReqLogin::set_pwd(const char* value, size_t size) {
  
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.game.ReqLogin.pwd)
}
inline ::std::string* ReqLogin::mutable_pwd() {
  
  // @@protoc_insertion_point(field_mutable:proto.game.ReqLogin.pwd)
  return pwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqLogin::release_pwd() {
  // @@protoc_insertion_point(field_release:proto.game.ReqLogin.pwd)
  
  return pwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqLogin::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    
  } else {
    
  }
  pwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd);
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqLogin.pwd)
}

// -------------------------------------------------------------------

// ReqLoginUc

// int32 code = 1;
inline void ReqLoginUc::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ReqLoginUc::code() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqLoginUc.code)
  return code_;
}
inline void ReqLoginUc::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqLoginUc.code)
}

// .proto.game.Player player = 2;
inline bool ReqLoginUc::has_player() const {
  return this != internal_default_instance() && player_ != NULL;
}
inline void ReqLoginUc::clear_player() {
  if (GetArenaNoVirtual() == NULL && player_ != NULL) {
    delete player_;
  }
  player_ = NULL;
}
inline const ::proto::game::Player& ReqLoginUc::player() const {
  const ::proto::game::Player* p = player_;
  // @@protoc_insertion_point(field_get:proto.game.ReqLoginUc.player)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Player*>(
      &::proto::game::_Player_default_instance_);
}
inline ::proto::game::Player* ReqLoginUc::release_player() {
  // @@protoc_insertion_point(field_release:proto.game.ReqLoginUc.player)
  
  ::proto::game::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::proto::game::Player* ReqLoginUc::mutable_player() {
  
  if (player_ == NULL) {
    player_ = ::google::protobuf::Arena::Create< ::proto::game::Player >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqLoginUc.player)
  return player_;
}
inline void ReqLoginUc::set_allocated_player(::proto::game::Player* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqLoginUc.player)
}

// -------------------------------------------------------------------

// ReqLogout

// .proto.game.Player player = 1;
inline bool ReqLogout::has_player() const {
  return this != internal_default_instance() && player_ != NULL;
}
inline void ReqLogout::clear_player() {
  if (GetArenaNoVirtual() == NULL && player_ != NULL) {
    delete player_;
  }
  player_ = NULL;
}
inline const ::proto::game::Player& ReqLogout::player() const {
  const ::proto::game::Player* p = player_;
  // @@protoc_insertion_point(field_get:proto.game.ReqLogout.player)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Player*>(
      &::proto::game::_Player_default_instance_);
}
inline ::proto::game::Player* ReqLogout::release_player() {
  // @@protoc_insertion_point(field_release:proto.game.ReqLogout.player)
  
  ::proto::game::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::proto::game::Player* ReqLogout::mutable_player() {
  
  if (player_ == NULL) {
    player_ = ::google::protobuf::Arena::Create< ::proto::game::Player >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqLogout.player)
  return player_;
}
inline void ReqLogout::set_allocated_player(::proto::game::Player* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqLogout.player)
}

// -------------------------------------------------------------------

// ReqLogoutUc

// int32 code = 1;
inline void ReqLogoutUc::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ReqLogoutUc::code() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqLogoutUc.code)
  return code_;
}
inline void ReqLogoutUc::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqLogoutUc.code)
}

// string remark = 2;
inline void ReqLogoutUc::clear_remark() {
  remark_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqLogoutUc::remark() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqLogoutUc.remark)
  return remark_.GetNoArena();
}
inline void ReqLogoutUc::set_remark(const ::std::string& value) {
  
  remark_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.game.ReqLogoutUc.remark)
}
#if LANG_CXX11
inline void ReqLogoutUc::set_remark(::std::string&& value) {
  
  remark_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.game.ReqLogoutUc.remark)
}
#endif
inline void ReqLogoutUc::set_remark(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remark_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.game.ReqLogoutUc.remark)
}
inline void ReqLogoutUc::set_remark(const char* value, size_t size) {
  
  remark_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.game.ReqLogoutUc.remark)
}
inline ::std::string* ReqLogoutUc::mutable_remark() {
  
  // @@protoc_insertion_point(field_mutable:proto.game.ReqLogoutUc.remark)
  return remark_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqLogoutUc::release_remark() {
  // @@protoc_insertion_point(field_release:proto.game.ReqLogoutUc.remark)
  
  return remark_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqLogoutUc::set_allocated_remark(::std::string* remark) {
  if (remark != NULL) {
    
  } else {
    
  }
  remark_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remark);
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqLogoutUc.remark)
}

// -------------------------------------------------------------------

// ReqRegist

// .proto.game.Player player = 1;
inline bool ReqRegist::has_player() const {
  return this != internal_default_instance() && player_ != NULL;
}
inline void ReqRegist::clear_player() {
  if (GetArenaNoVirtual() == NULL && player_ != NULL) {
    delete player_;
  }
  player_ = NULL;
}
inline const ::proto::game::Player& ReqRegist::player() const {
  const ::proto::game::Player* p = player_;
  // @@protoc_insertion_point(field_get:proto.game.ReqRegist.player)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Player*>(
      &::proto::game::_Player_default_instance_);
}
inline ::proto::game::Player* ReqRegist::release_player() {
  // @@protoc_insertion_point(field_release:proto.game.ReqRegist.player)
  
  ::proto::game::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::proto::game::Player* ReqRegist::mutable_player() {
  
  if (player_ == NULL) {
    player_ = ::google::protobuf::Arena::Create< ::proto::game::Player >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqRegist.player)
  return player_;
}
inline void ReqRegist::set_allocated_player(::proto::game::Player* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqRegist.player)
}

// -------------------------------------------------------------------

// ReqRegistUc

// int32 code = 1;
inline void ReqRegistUc::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ReqRegistUc::code() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqRegistUc.code)
  return code_;
}
inline void ReqRegistUc::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqRegistUc.code)
}

// .proto.game.Player player = 2;
inline bool ReqRegistUc::has_player() const {
  return this != internal_default_instance() && player_ != NULL;
}
inline void ReqRegistUc::clear_player() {
  if (GetArenaNoVirtual() == NULL && player_ != NULL) {
    delete player_;
  }
  player_ = NULL;
}
inline const ::proto::game::Player& ReqRegistUc::player() const {
  const ::proto::game::Player* p = player_;
  // @@protoc_insertion_point(field_get:proto.game.ReqRegistUc.player)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Player*>(
      &::proto::game::_Player_default_instance_);
}
inline ::proto::game::Player* ReqRegistUc::release_player() {
  // @@protoc_insertion_point(field_release:proto.game.ReqRegistUc.player)
  
  ::proto::game::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::proto::game::Player* ReqRegistUc::mutable_player() {
  
  if (player_ == NULL) {
    player_ = ::google::protobuf::Arena::Create< ::proto::game::Player >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqRegistUc.player)
  return player_;
}
inline void ReqRegistUc::set_allocated_player(::proto::game::Player* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqRegistUc.player)
}

// -------------------------------------------------------------------

// ReqUpdatePwd

// string account = 1;
inline void ReqUpdatePwd::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqUpdatePwd::account() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqUpdatePwd.account)
  return account_.GetNoArena();
}
inline void ReqUpdatePwd::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.game.ReqUpdatePwd.account)
}
#if LANG_CXX11
inline void ReqUpdatePwd::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.game.ReqUpdatePwd.account)
}
#endif
inline void ReqUpdatePwd::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.game.ReqUpdatePwd.account)
}
inline void ReqUpdatePwd::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.game.ReqUpdatePwd.account)
}
inline ::std::string* ReqUpdatePwd::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:proto.game.ReqUpdatePwd.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqUpdatePwd::release_account() {
  // @@protoc_insertion_point(field_release:proto.game.ReqUpdatePwd.account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqUpdatePwd::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqUpdatePwd.account)
}

// string oldpasswd = 2;
inline void ReqUpdatePwd::clear_oldpasswd() {
  oldpasswd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqUpdatePwd::oldpasswd() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqUpdatePwd.oldpasswd)
  return oldpasswd_.GetNoArena();
}
inline void ReqUpdatePwd::set_oldpasswd(const ::std::string& value) {
  
  oldpasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.game.ReqUpdatePwd.oldpasswd)
}
#if LANG_CXX11
inline void ReqUpdatePwd::set_oldpasswd(::std::string&& value) {
  
  oldpasswd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.game.ReqUpdatePwd.oldpasswd)
}
#endif
inline void ReqUpdatePwd::set_oldpasswd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  oldpasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.game.ReqUpdatePwd.oldpasswd)
}
inline void ReqUpdatePwd::set_oldpasswd(const char* value, size_t size) {
  
  oldpasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.game.ReqUpdatePwd.oldpasswd)
}
inline ::std::string* ReqUpdatePwd::mutable_oldpasswd() {
  
  // @@protoc_insertion_point(field_mutable:proto.game.ReqUpdatePwd.oldpasswd)
  return oldpasswd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqUpdatePwd::release_oldpasswd() {
  // @@protoc_insertion_point(field_release:proto.game.ReqUpdatePwd.oldpasswd)
  
  return oldpasswd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqUpdatePwd::set_allocated_oldpasswd(::std::string* oldpasswd) {
  if (oldpasswd != NULL) {
    
  } else {
    
  }
  oldpasswd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oldpasswd);
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqUpdatePwd.oldpasswd)
}

// string newpasswd = 3;
inline void ReqUpdatePwd::clear_newpasswd() {
  newpasswd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqUpdatePwd::newpasswd() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqUpdatePwd.newpasswd)
  return newpasswd_.GetNoArena();
}
inline void ReqUpdatePwd::set_newpasswd(const ::std::string& value) {
  
  newpasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.game.ReqUpdatePwd.newpasswd)
}
#if LANG_CXX11
inline void ReqUpdatePwd::set_newpasswd(::std::string&& value) {
  
  newpasswd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.game.ReqUpdatePwd.newpasswd)
}
#endif
inline void ReqUpdatePwd::set_newpasswd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  newpasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.game.ReqUpdatePwd.newpasswd)
}
inline void ReqUpdatePwd::set_newpasswd(const char* value, size_t size) {
  
  newpasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.game.ReqUpdatePwd.newpasswd)
}
inline ::std::string* ReqUpdatePwd::mutable_newpasswd() {
  
  // @@protoc_insertion_point(field_mutable:proto.game.ReqUpdatePwd.newpasswd)
  return newpasswd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqUpdatePwd::release_newpasswd() {
  // @@protoc_insertion_point(field_release:proto.game.ReqUpdatePwd.newpasswd)
  
  return newpasswd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqUpdatePwd::set_allocated_newpasswd(::std::string* newpasswd) {
  if (newpasswd != NULL) {
    
  } else {
    
  }
  newpasswd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), newpasswd);
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqUpdatePwd.newpasswd)
}

// -------------------------------------------------------------------

// ReqUpdatePwdUc

// int32 code = 1;
inline void ReqUpdatePwdUc::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ReqUpdatePwdUc::code() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqUpdatePwdUc.code)
  return code_;
}
inline void ReqUpdatePwdUc::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqUpdatePwdUc.code)
}

// -------------------------------------------------------------------

// ReqGetFriends

// -------------------------------------------------------------------

// ReqGetFriendsUc

// int32 code = 1;
inline void ReqGetFriendsUc::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ReqGetFriendsUc::code() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqGetFriendsUc.code)
  return code_;
}
inline void ReqGetFriendsUc::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqGetFriendsUc.code)
}

// repeated .proto.game.Player frieds = 2;
inline int ReqGetFriendsUc::frieds_size() const {
  return frieds_.size();
}
inline void ReqGetFriendsUc::clear_frieds() {
  frieds_.Clear();
}
inline ::proto::game::Player* ReqGetFriendsUc::mutable_frieds(int index) {
  // @@protoc_insertion_point(field_mutable:proto.game.ReqGetFriendsUc.frieds)
  return frieds_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::game::Player >*
ReqGetFriendsUc::mutable_frieds() {
  // @@protoc_insertion_point(field_mutable_list:proto.game.ReqGetFriendsUc.frieds)
  return &frieds_;
}
inline const ::proto::game::Player& ReqGetFriendsUc::frieds(int index) const {
  // @@protoc_insertion_point(field_get:proto.game.ReqGetFriendsUc.frieds)
  return frieds_.Get(index);
}
inline ::proto::game::Player* ReqGetFriendsUc::add_frieds() {
  // @@protoc_insertion_point(field_add:proto.game.ReqGetFriendsUc.frieds)
  return frieds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::game::Player >&
ReqGetFriendsUc::frieds() const {
  // @@protoc_insertion_point(field_list:proto.game.ReqGetFriendsUc.frieds)
  return frieds_;
}

// -------------------------------------------------------------------

// ReqAddFriends

// .proto.game.Player friend = 1;
inline bool ReqAddFriends::has_friend_() const {
  return this != internal_default_instance() && friend__ != NULL;
}
inline void ReqAddFriends::clear_friend_() {
  if (GetArenaNoVirtual() == NULL && friend__ != NULL) {
    delete friend__;
  }
  friend__ = NULL;
}
inline const ::proto::game::Player& ReqAddFriends::friend_() const {
  const ::proto::game::Player* p = friend__;
  // @@protoc_insertion_point(field_get:proto.game.ReqAddFriends.friend)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Player*>(
      &::proto::game::_Player_default_instance_);
}
inline ::proto::game::Player* ReqAddFriends::release_friend_() {
  // @@protoc_insertion_point(field_release:proto.game.ReqAddFriends.friend)
  
  ::proto::game::Player* temp = friend__;
  friend__ = NULL;
  return temp;
}
inline ::proto::game::Player* ReqAddFriends::mutable_friend_() {
  
  if (friend__ == NULL) {
    friend__ = ::google::protobuf::Arena::Create< ::proto::game::Player >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqAddFriends.friend)
  return friend__;
}
inline void ReqAddFriends::set_allocated_friend_(::proto::game::Player* friend_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete friend__;
  }
  if (friend_) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      friend_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, friend_, submessage_arena);
    }
    
  } else {
    
  }
  friend__ = friend_;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqAddFriends.friend)
}

// -------------------------------------------------------------------

// ReqAddFriendsUc

// int32 code = 1;
inline void ReqAddFriendsUc::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ReqAddFriendsUc::code() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqAddFriendsUc.code)
  return code_;
}
inline void ReqAddFriendsUc::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqAddFriendsUc.code)
}

// .proto.game.Player friend = 2;
inline bool ReqAddFriendsUc::has_friend_() const {
  return this != internal_default_instance() && friend__ != NULL;
}
inline void ReqAddFriendsUc::clear_friend_() {
  if (GetArenaNoVirtual() == NULL && friend__ != NULL) {
    delete friend__;
  }
  friend__ = NULL;
}
inline const ::proto::game::Player& ReqAddFriendsUc::friend_() const {
  const ::proto::game::Player* p = friend__;
  // @@protoc_insertion_point(field_get:proto.game.ReqAddFriendsUc.friend)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Player*>(
      &::proto::game::_Player_default_instance_);
}
inline ::proto::game::Player* ReqAddFriendsUc::release_friend_() {
  // @@protoc_insertion_point(field_release:proto.game.ReqAddFriendsUc.friend)
  
  ::proto::game::Player* temp = friend__;
  friend__ = NULL;
  return temp;
}
inline ::proto::game::Player* ReqAddFriendsUc::mutable_friend_() {
  
  if (friend__ == NULL) {
    friend__ = ::google::protobuf::Arena::Create< ::proto::game::Player >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqAddFriendsUc.friend)
  return friend__;
}
inline void ReqAddFriendsUc::set_allocated_friend_(::proto::game::Player* friend_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete friend__;
  }
  if (friend_) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      friend_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, friend_, submessage_arena);
    }
    
  } else {
    
  }
  friend__ = friend_;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqAddFriendsUc.friend)
}

// -------------------------------------------------------------------

// ReqDeleteFriend

// .proto.game.Player friend = 1;
inline bool ReqDeleteFriend::has_friend_() const {
  return this != internal_default_instance() && friend__ != NULL;
}
inline void ReqDeleteFriend::clear_friend_() {
  if (GetArenaNoVirtual() == NULL && friend__ != NULL) {
    delete friend__;
  }
  friend__ = NULL;
}
inline const ::proto::game::Player& ReqDeleteFriend::friend_() const {
  const ::proto::game::Player* p = friend__;
  // @@protoc_insertion_point(field_get:proto.game.ReqDeleteFriend.friend)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Player*>(
      &::proto::game::_Player_default_instance_);
}
inline ::proto::game::Player* ReqDeleteFriend::release_friend_() {
  // @@protoc_insertion_point(field_release:proto.game.ReqDeleteFriend.friend)
  
  ::proto::game::Player* temp = friend__;
  friend__ = NULL;
  return temp;
}
inline ::proto::game::Player* ReqDeleteFriend::mutable_friend_() {
  
  if (friend__ == NULL) {
    friend__ = ::google::protobuf::Arena::Create< ::proto::game::Player >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqDeleteFriend.friend)
  return friend__;
}
inline void ReqDeleteFriend::set_allocated_friend_(::proto::game::Player* friend_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete friend__;
  }
  if (friend_) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      friend_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, friend_, submessage_arena);
    }
    
  } else {
    
  }
  friend__ = friend_;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqDeleteFriend.friend)
}

// -------------------------------------------------------------------

// ReqDeleteFriendUc

// int32 code = 2;
inline void ReqDeleteFriendUc::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ReqDeleteFriendUc::code() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqDeleteFriendUc.code)
  return code_;
}
inline void ReqDeleteFriendUc::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqDeleteFriendUc.code)
}

// -------------------------------------------------------------------

// Room

// int32 room_id = 1;
inline void Room::clear_room_id() {
  room_id_ = 0;
}
inline ::google::protobuf::int32 Room::room_id() const {
  // @@protoc_insertion_point(field_get:proto.game.Room.room_id)
  return room_id_;
}
inline void Room::set_room_id(::google::protobuf::int32 value) {
  
  room_id_ = value;
  // @@protoc_insertion_point(field_set:proto.game.Room.room_id)
}

// string name = 2;
inline void Room::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Room::name() const {
  // @@protoc_insertion_point(field_get:proto.game.Room.name)
  return name_.GetNoArena();
}
inline void Room::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.game.Room.name)
}
#if LANG_CXX11
inline void Room::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.game.Room.name)
}
#endif
inline void Room::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.game.Room.name)
}
inline void Room::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.game.Room.name)
}
inline ::std::string* Room::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.game.Room.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Room::release_name() {
  // @@protoc_insertion_point(field_release:proto.game.Room.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Room::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.game.Room.name)
}

// int32 type = 3;
inline void Room::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 Room::type() const {
  // @@protoc_insertion_point(field_get:proto.game.Room.type)
  return type_;
}
inline void Room::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.game.Room.type)
}

// int32 max_player_cnt = 4;
inline void Room::clear_max_player_cnt() {
  max_player_cnt_ = 0;
}
inline ::google::protobuf::int32 Room::max_player_cnt() const {
  // @@protoc_insertion_point(field_get:proto.game.Room.max_player_cnt)
  return max_player_cnt_;
}
inline void Room::set_max_player_cnt(::google::protobuf::int32 value) {
  
  max_player_cnt_ = value;
  // @@protoc_insertion_point(field_set:proto.game.Room.max_player_cnt)
}

// int32 player_cnt = 5;
inline void Room::clear_player_cnt() {
  player_cnt_ = 0;
}
inline ::google::protobuf::int32 Room::player_cnt() const {
  // @@protoc_insertion_point(field_get:proto.game.Room.player_cnt)
  return player_cnt_;
}
inline void Room::set_player_cnt(::google::protobuf::int32 value) {
  
  player_cnt_ = value;
  // @@protoc_insertion_point(field_set:proto.game.Room.player_cnt)
}

// int32 match_seat_way = 6;
inline void Room::clear_match_seat_way() {
  match_seat_way_ = 0;
}
inline ::google::protobuf::int32 Room::match_seat_way() const {
  // @@protoc_insertion_point(field_get:proto.game.Room.match_seat_way)
  return match_seat_way_;
}
inline void Room::set_match_seat_way(::google::protobuf::int32 value) {
  
  match_seat_way_ = value;
  // @@protoc_insertion_point(field_set:proto.game.Room.match_seat_way)
}

// int32 status = 7;
inline void Room::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 Room::status() const {
  // @@protoc_insertion_point(field_get:proto.game.Room.status)
  return status_;
}
inline void Room::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:proto.game.Room.status)
}

// repeated .proto.game.Player players = 8;
inline int Room::players_size() const {
  return players_.size();
}
inline void Room::clear_players() {
  players_.Clear();
}
inline ::proto::game::Player* Room::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:proto.game.Room.players)
  return players_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::game::Player >*
Room::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:proto.game.Room.players)
  return &players_;
}
inline const ::proto::game::Player& Room::players(int index) const {
  // @@protoc_insertion_point(field_get:proto.game.Room.players)
  return players_.Get(index);
}
inline ::proto::game::Player* Room::add_players() {
  // @@protoc_insertion_point(field_add:proto.game.Room.players)
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::game::Player >&
Room::players() const {
  // @@protoc_insertion_point(field_list:proto.game.Room.players)
  return players_;
}

// .proto.game.Player master = 9;
inline bool Room::has_master() const {
  return this != internal_default_instance() && master_ != NULL;
}
inline void Room::clear_master() {
  if (GetArenaNoVirtual() == NULL && master_ != NULL) {
    delete master_;
  }
  master_ = NULL;
}
inline const ::proto::game::Player& Room::master() const {
  const ::proto::game::Player* p = master_;
  // @@protoc_insertion_point(field_get:proto.game.Room.master)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Player*>(
      &::proto::game::_Player_default_instance_);
}
inline ::proto::game::Player* Room::release_master() {
  // @@protoc_insertion_point(field_release:proto.game.Room.master)
  
  ::proto::game::Player* temp = master_;
  master_ = NULL;
  return temp;
}
inline ::proto::game::Player* Room::mutable_master() {
  
  if (master_ == NULL) {
    master_ = ::google::protobuf::Arena::Create< ::proto::game::Player >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.Room.master)
  return master_;
}
inline void Room::set_allocated_master(::proto::game::Player* master) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete master_;
  }
  if (master) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      master = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, master, submessage_arena);
    }
    
  } else {
    
  }
  master_ = master;
  // @@protoc_insertion_point(field_set_allocated:proto.game.Room.master)
}

// -------------------------------------------------------------------

// ReqCreateRoom

// .proto.game.Room room = 1;
inline bool ReqCreateRoom::has_room() const {
  return this != internal_default_instance() && room_ != NULL;
}
inline void ReqCreateRoom::clear_room() {
  if (GetArenaNoVirtual() == NULL && room_ != NULL) {
    delete room_;
  }
  room_ = NULL;
}
inline const ::proto::game::Room& ReqCreateRoom::room() const {
  const ::proto::game::Room* p = room_;
  // @@protoc_insertion_point(field_get:proto.game.ReqCreateRoom.room)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Room*>(
      &::proto::game::_Room_default_instance_);
}
inline ::proto::game::Room* ReqCreateRoom::release_room() {
  // @@protoc_insertion_point(field_release:proto.game.ReqCreateRoom.room)
  
  ::proto::game::Room* temp = room_;
  room_ = NULL;
  return temp;
}
inline ::proto::game::Room* ReqCreateRoom::mutable_room() {
  
  if (room_ == NULL) {
    room_ = ::google::protobuf::Arena::Create< ::proto::game::Room >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqCreateRoom.room)
  return room_;
}
inline void ReqCreateRoom::set_allocated_room(::proto::game::Room* room) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_;
  }
  if (room) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      room = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  room_ = room;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqCreateRoom.room)
}

// -------------------------------------------------------------------

// ReqCreateRoomUc

// int32 code = 1;
inline void ReqCreateRoomUc::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ReqCreateRoomUc::code() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqCreateRoomUc.code)
  return code_;
}
inline void ReqCreateRoomUc::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqCreateRoomUc.code)
}

// .proto.game.Room room = 2;
inline bool ReqCreateRoomUc::has_room() const {
  return this != internal_default_instance() && room_ != NULL;
}
inline void ReqCreateRoomUc::clear_room() {
  if (GetArenaNoVirtual() == NULL && room_ != NULL) {
    delete room_;
  }
  room_ = NULL;
}
inline const ::proto::game::Room& ReqCreateRoomUc::room() const {
  const ::proto::game::Room* p = room_;
  // @@protoc_insertion_point(field_get:proto.game.ReqCreateRoomUc.room)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Room*>(
      &::proto::game::_Room_default_instance_);
}
inline ::proto::game::Room* ReqCreateRoomUc::release_room() {
  // @@protoc_insertion_point(field_release:proto.game.ReqCreateRoomUc.room)
  
  ::proto::game::Room* temp = room_;
  room_ = NULL;
  return temp;
}
inline ::proto::game::Room* ReqCreateRoomUc::mutable_room() {
  
  if (room_ == NULL) {
    room_ = ::google::protobuf::Arena::Create< ::proto::game::Room >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqCreateRoomUc.room)
  return room_;
}
inline void ReqCreateRoomUc::set_allocated_room(::proto::game::Room* room) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_;
  }
  if (room) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      room = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  room_ = room;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqCreateRoomUc.room)
}

// -------------------------------------------------------------------

// ReqSearchRoom

// int32 roomid = 1;
inline void ReqSearchRoom::clear_roomid() {
  roomid_ = 0;
}
inline ::google::protobuf::int32 ReqSearchRoom::roomid() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqSearchRoom.roomid)
  return roomid_;
}
inline void ReqSearchRoom::set_roomid(::google::protobuf::int32 value) {
  
  roomid_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqSearchRoom.roomid)
}

// -------------------------------------------------------------------

// ReqSearchRoomUc

// int32 code = 1;
inline void ReqSearchRoomUc::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ReqSearchRoomUc::code() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqSearchRoomUc.code)
  return code_;
}
inline void ReqSearchRoomUc::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqSearchRoomUc.code)
}

// .proto.game.Room room = 2;
inline bool ReqSearchRoomUc::has_room() const {
  return this != internal_default_instance() && room_ != NULL;
}
inline void ReqSearchRoomUc::clear_room() {
  if (GetArenaNoVirtual() == NULL && room_ != NULL) {
    delete room_;
  }
  room_ = NULL;
}
inline const ::proto::game::Room& ReqSearchRoomUc::room() const {
  const ::proto::game::Room* p = room_;
  // @@protoc_insertion_point(field_get:proto.game.ReqSearchRoomUc.room)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Room*>(
      &::proto::game::_Room_default_instance_);
}
inline ::proto::game::Room* ReqSearchRoomUc::release_room() {
  // @@protoc_insertion_point(field_release:proto.game.ReqSearchRoomUc.room)
  
  ::proto::game::Room* temp = room_;
  room_ = NULL;
  return temp;
}
inline ::proto::game::Room* ReqSearchRoomUc::mutable_room() {
  
  if (room_ == NULL) {
    room_ = ::google::protobuf::Arena::Create< ::proto::game::Room >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqSearchRoomUc.room)
  return room_;
}
inline void ReqSearchRoomUc::set_allocated_room(::proto::game::Room* room) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_;
  }
  if (room) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      room = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  room_ = room;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqSearchRoomUc.room)
}

// -------------------------------------------------------------------

// ReqEnterRoom

// int32 roomid = 1;
inline void ReqEnterRoom::clear_roomid() {
  roomid_ = 0;
}
inline ::google::protobuf::int32 ReqEnterRoom::roomid() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqEnterRoom.roomid)
  return roomid_;
}
inline void ReqEnterRoom::set_roomid(::google::protobuf::int32 value) {
  
  roomid_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqEnterRoom.roomid)
}

// -------------------------------------------------------------------

// ReqEnterRoomFast

// -------------------------------------------------------------------

// ReqEnterRoomBc

// int32 code = 1;
inline void ReqEnterRoomBc::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ReqEnterRoomBc::code() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqEnterRoomBc.code)
  return code_;
}
inline void ReqEnterRoomBc::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqEnterRoomBc.code)
}

// .proto.game.Player player = 2;
inline bool ReqEnterRoomBc::has_player() const {
  return this != internal_default_instance() && player_ != NULL;
}
inline void ReqEnterRoomBc::clear_player() {
  if (GetArenaNoVirtual() == NULL && player_ != NULL) {
    delete player_;
  }
  player_ = NULL;
}
inline const ::proto::game::Player& ReqEnterRoomBc::player() const {
  const ::proto::game::Player* p = player_;
  // @@protoc_insertion_point(field_get:proto.game.ReqEnterRoomBc.player)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Player*>(
      &::proto::game::_Player_default_instance_);
}
inline ::proto::game::Player* ReqEnterRoomBc::release_player() {
  // @@protoc_insertion_point(field_release:proto.game.ReqEnterRoomBc.player)
  
  ::proto::game::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::proto::game::Player* ReqEnterRoomBc::mutable_player() {
  
  if (player_ == NULL) {
    player_ = ::google::protobuf::Arena::Create< ::proto::game::Player >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqEnterRoomBc.player)
  return player_;
}
inline void ReqEnterRoomBc::set_allocated_player(::proto::game::Player* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqEnterRoomBc.player)
}

// .proto.game.Room room = 3;
inline bool ReqEnterRoomBc::has_room() const {
  return this != internal_default_instance() && room_ != NULL;
}
inline void ReqEnterRoomBc::clear_room() {
  if (GetArenaNoVirtual() == NULL && room_ != NULL) {
    delete room_;
  }
  room_ = NULL;
}
inline const ::proto::game::Room& ReqEnterRoomBc::room() const {
  const ::proto::game::Room* p = room_;
  // @@protoc_insertion_point(field_get:proto.game.ReqEnterRoomBc.room)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Room*>(
      &::proto::game::_Room_default_instance_);
}
inline ::proto::game::Room* ReqEnterRoomBc::release_room() {
  // @@protoc_insertion_point(field_release:proto.game.ReqEnterRoomBc.room)
  
  ::proto::game::Room* temp = room_;
  room_ = NULL;
  return temp;
}
inline ::proto::game::Room* ReqEnterRoomBc::mutable_room() {
  
  if (room_ == NULL) {
    room_ = ::google::protobuf::Arena::Create< ::proto::game::Room >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqEnterRoomBc.room)
  return room_;
}
inline void ReqEnterRoomBc::set_allocated_room(::proto::game::Room* room) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_;
  }
  if (room) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      room = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  room_ = room;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqEnterRoomBc.room)
}

// -------------------------------------------------------------------

// ReqQuitRoom

// int32 roomid = 1;
inline void ReqQuitRoom::clear_roomid() {
  roomid_ = 0;
}
inline ::google::protobuf::int32 ReqQuitRoom::roomid() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqQuitRoom.roomid)
  return roomid_;
}
inline void ReqQuitRoom::set_roomid(::google::protobuf::int32 value) {
  
  roomid_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqQuitRoom.roomid)
}

// -------------------------------------------------------------------

// ReqQuitRoomBc

// int32 code = 1;
inline void ReqQuitRoomBc::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ReqQuitRoomBc::code() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqQuitRoomBc.code)
  return code_;
}
inline void ReqQuitRoomBc::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqQuitRoomBc.code)
}

// .proto.game.Player player = 2;
inline bool ReqQuitRoomBc::has_player() const {
  return this != internal_default_instance() && player_ != NULL;
}
inline void ReqQuitRoomBc::clear_player() {
  if (GetArenaNoVirtual() == NULL && player_ != NULL) {
    delete player_;
  }
  player_ = NULL;
}
inline const ::proto::game::Player& ReqQuitRoomBc::player() const {
  const ::proto::game::Player* p = player_;
  // @@protoc_insertion_point(field_get:proto.game.ReqQuitRoomBc.player)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Player*>(
      &::proto::game::_Player_default_instance_);
}
inline ::proto::game::Player* ReqQuitRoomBc::release_player() {
  // @@protoc_insertion_point(field_release:proto.game.ReqQuitRoomBc.player)
  
  ::proto::game::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::proto::game::Player* ReqQuitRoomBc::mutable_player() {
  
  if (player_ == NULL) {
    player_ = ::google::protobuf::Arena::Create< ::proto::game::Player >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqQuitRoomBc.player)
  return player_;
}
inline void ReqQuitRoomBc::set_allocated_player(::proto::game::Player* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqQuitRoomBc.player)
}

// -------------------------------------------------------------------

// ReqReady

// int32 roomid = 1;
inline void ReqReady::clear_roomid() {
  roomid_ = 0;
}
inline ::google::protobuf::int32 ReqReady::roomid() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqReady.roomid)
  return roomid_;
}
inline void ReqReady::set_roomid(::google::protobuf::int32 value) {
  
  roomid_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqReady.roomid)
}

// -------------------------------------------------------------------

// ReqReadyBc

// int32 code = 1;
inline void ReqReadyBc::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ReqReadyBc::code() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqReadyBc.code)
  return code_;
}
inline void ReqReadyBc::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqReadyBc.code)
}

// .proto.game.Player player = 2;
inline bool ReqReadyBc::has_player() const {
  return this != internal_default_instance() && player_ != NULL;
}
inline void ReqReadyBc::clear_player() {
  if (GetArenaNoVirtual() == NULL && player_ != NULL) {
    delete player_;
  }
  player_ = NULL;
}
inline const ::proto::game::Player& ReqReadyBc::player() const {
  const ::proto::game::Player* p = player_;
  // @@protoc_insertion_point(field_get:proto.game.ReqReadyBc.player)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::game::Player*>(
      &::proto::game::_Player_default_instance_);
}
inline ::proto::game::Player* ReqReadyBc::release_player() {
  // @@protoc_insertion_point(field_release:proto.game.ReqReadyBc.player)
  
  ::proto::game::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::proto::game::Player* ReqReadyBc::mutable_player() {
  
  if (player_ == NULL) {
    player_ = ::google::protobuf::Arena::Create< ::proto::game::Player >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.game.ReqReadyBc.player)
  return player_;
}
inline void ReqReadyBc::set_allocated_player(::proto::game::Player* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:proto.game.ReqReadyBc.player)
}

// -------------------------------------------------------------------

// ReqEmotionBC

// int32 seatid = 1;
inline void ReqEmotionBC::clear_seatid() {
  seatid_ = 0;
}
inline ::google::protobuf::int32 ReqEmotionBC::seatid() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqEmotionBC.seatid)
  return seatid_;
}
inline void ReqEmotionBC::set_seatid(::google::protobuf::int32 value) {
  
  seatid_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqEmotionBC.seatid)
}

// int32 type = 2;
inline void ReqEmotionBC::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 ReqEmotionBC::type() const {
  // @@protoc_insertion_point(field_get:proto.game.ReqEmotionBC.type)
  return type_;
}
inline void ReqEmotionBC::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.game.ReqEmotionBC.type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace game
}  // namespace proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_appproto_2eproto_INCLUDED
